// controllers/matchingIncomeController.js - IMMEDIATE APPROVAL VERSION
import { MatchingIncomeRecord } from '../models/matchingIncomeSchema.js';
import { User } from '../models/userSchema.js';
import { Plot } from '../models/plotBooking.js';
import mongoose from 'mongoose';

/* ============================================================================ */
/* ðŸ”· USER CONTROLLERS                                                         */
/* ============================================================================ */

/**
 * Get individual matching income records for a user
 * GET /api/matching-income/user/:userId
 */
export const getUserMatchingIncome = async (req, res) => {
  try {
    const { userId } = req.params;
    const {
      incomeType,
      status,
      legType,
      startDate,
      endDate,
      page = 1,
      limit = 20,
      sortBy = 'saleDate',
      sortOrder = 'desc'
    } = req.query;

    // Build query
    const query = { userId };

    if (incomeType) query.incomeType = incomeType;
    if (status) query.status = status;
    if (legType) query.legType = legType;
    if (startDate || endDate) {
      query.saleDate = {};
      if (startDate) query.saleDate.$gte = new Date(startDate);
      if (endDate) query.saleDate.$lte = new Date(endDate);
    }

    // Pagination
    const skip = (page - 1) * limit;
    const sortOptions = { [sortBy]: sortOrder === 'asc' ? 1 : -1 };

    // Execute query with population
    const records = await MatchingIncomeRecord.find(query)
      .populate('userId', 'username email personalInfo')
      .populate('plotId', 'plotNumber plotName')
      .populate('buyerId', 'username personalInfo')
      .populate('triggeredByPlotId', 'plotNumber plotName')
      .populate('pairedWith.plotId', 'plotNumber plotName')
      .populate('pairedWith.buyerId', 'username personalInfo')
      .populate('approvedBy', 'username')
      .populate('rejectedBy', 'username')
      .sort(sortOptions)
      .skip(skip)
      .limit(parseInt(limit))
      .lean();

    // Get total count for pagination
    const totalRecords = await MatchingIncomeRecord.countDocuments(query);

    // Calculate summary statistics
    const summaryPipeline = [
      { $match: query },
      {
        $group: {
          _id: null,
          totalIncome: { $sum: '$incomeAmount' },
          totalRecords: { $sum: 1 },
          totalSales: { $sum: '$saleAmount' }
        }
      }
    ];

    const summaryResult = await MatchingIncomeRecord.aggregate(summaryPipeline);
    const summary = summaryResult[0] || { totalIncome: 0, totalRecords: 0, totalSales: 0 };

    // Income by type
    const incomeByType = await MatchingIncomeRecord.aggregate([
      { $match: query },
      {
        $group: {
          _id: '$incomeType',
          total: { $sum: '$incomeAmount' },
          count: { $sum: 1 }
        }
      }
    ]);

    summary.incomeByType = {};
    incomeByType.forEach(item => {
      summary.incomeByType[item._id] = item.total;
    });

    // Income by status
    const incomeByStatus = await MatchingIncomeRecord.aggregate([
      { $match: query },
      {
        $group: {
          _id: '$status',
          total: { $sum: '$incomeAmount' },
          count: { $sum: 1 }
        }
      }
    ]);

    summary.incomeByStatus = {};
    incomeByStatus.forEach(item => {
      summary.incomeByStatus[item._id] = item.total;
    });

    // Eligible for approval (all eligible status records)
    const eligibleRecords = await MatchingIncomeRecord.find({
      ...query,
      status: 'eligible'
    });

    summary.eligibleForApproval = {
      count: eligibleRecords.length,
      amount: eligibleRecords.reduce((sum, r) => sum + r.incomeAmount, 0)
    };

    res.status(200).json({
      success: true,
      data: records,
      summary,
      pagination: {
        currentPage: parseInt(page),
        totalPages: Math.ceil(totalRecords / limit),
        totalRecords,
        limit: parseInt(limit)
      }
    });

  } catch (error) {
    console.error('Error in getUserMatchingIncome:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'Failed to fetch income records'
    });
  }
};

/**
 * Get income details for a specific plot
 * GET /api/matching-income/plot/:plotId
 */
export const getPlotIncomeDetails = async (req, res) => {
  try {
    const { plotId } = req.params;

    // Get all income records generated by this plot
    const records = await MatchingIncomeRecord.find({
      $or: [
        { plotId },
        { triggeredByPlotId: plotId },
        { 'pairedWith.plotId': plotId }
      ]
    })
      .populate('userId', 'username email personalInfo')
      .populate('plotId', 'plotNumber plotName')
      .populate('buyerId', 'username personalInfo')
      .populate('triggeredByPlotId', 'plotNumber plotName')
      .sort({ saleDate: -1 })
      .lean();

    // Get plot details
    const plot = await Plot.findById(plotId)
      .populate('bookingDetails.buyerId', 'username personalInfo')
      .lean();

    if (!plot) {
      return res.status(404).json({
        success: false,
        message: 'Plot not found'
      });
    }

    // Calculate totals
    const totalIncome = records.reduce((sum, r) => sum + r.incomeAmount, 0);
    const personalSaleIncome = records
      .filter(r => r.incomeType === 'personal_sale')
      .reduce((sum, r) => sum + r.incomeAmount, 0);
    const matchingBonusIncome = records
      .filter(r => r.incomeType === 'matching_bonus')
      .reduce((sum, r) => sum + r.incomeAmount, 0);

    res.status(200).json({
      success: true,
      data: {
        plot,
        records,
        summary: {
          totalIncome,
          personalSaleIncome,
          matchingBonusIncome,
          totalRecords: records.length
        }
      }
    });

  } catch (error) {
    console.error('Error in getPlotIncomeDetails:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'Failed to fetch plot income details'
    });
  }
};

/**
 * Get income summary grouped by time period
 * GET /api/matching-income/summary/:userId
 */
export const getIncomeSummary = async (req, res) => {
  try {
    const { userId } = req.params;
    const { startDate, endDate, groupBy = 'month' } = req.query;

    const matchStage = { userId: new mongoose.Types.ObjectId(userId) };

    if (startDate || endDate) {
      matchStage.saleDate = {};
      if (startDate) matchStage.saleDate.$gte = new Date(startDate);
      if (endDate) matchStage.saleDate.$lte = new Date(endDate);
    }

    // Determine grouping format
    let dateFormat;
    switch (groupBy) {
      case 'day':
        dateFormat = { $dateToString: { format: '%Y-%m-%d', date: '$saleDate' } };
        break;
      case 'year':
        dateFormat = { $dateToString: { format: '%Y', date: '$saleDate' } };
        break;
      default: // month
        dateFormat = { $dateToString: { format: '%Y-%m', date: '$saleDate' } };
    }

    const pipeline = [
      { $match: matchStage },
      {
        $group: {
          _id: {
            period: dateFormat,
            incomeType: '$incomeType',
            status: '$status'
          },
          totalIncome: { $sum: '$incomeAmount' },
          totalSales: { $sum: '$saleAmount' },
          count: { $sum: 1 }
        }
      },
      { $sort: { '_id.period': 1 } }
    ];

    const results = await MatchingIncomeRecord.aggregate(pipeline);

    // Transform results into a more readable format
    const summary = {};
    results.forEach(item => {
      const period = item._id.period;
      if (!summary[period]) {
        summary[period] = {
          period,
          totalIncome: 0,
          totalSales: 0,
          totalRecords: 0,
          byType: {},
          byStatus: {}
        };
      }

      summary[period].totalIncome += item.totalIncome;
      summary[period].totalSales += item.totalSales;
      summary[period].totalRecords += item.count;

      if (!summary[period].byType[item._id.incomeType]) {
        summary[period].byType[item._id.incomeType] = 0;
      }
      summary[period].byType[item._id.incomeType] += item.totalIncome;

      if (!summary[period].byStatus[item._id.status]) {
        summary[period].byStatus[item._id.status] = 0;
      }
      summary[period].byStatus[item._id.status] += item.totalIncome;
    });

    res.status(200).json({
      success: true,
      data: Object.values(summary),
      groupBy
    });

  } catch (error) {
    console.error('Error in getIncomeSummary:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'Failed to fetch income summary'
    });
  }
};

/**
 * Get team income records (all downline members)
 * GET /api/matching-income/team/:userId
 */
export const getTeamMatchingIncome = async (req, res) => {
  try {
    const { userId } = req.params;
    const {
      incomeType,
      status,
      legType,
      startDate,
      endDate,
      memberId,
      page = 1,
      limit = 50,
      sortBy = 'saleDate',
      sortOrder = 'desc'
    } = req.query;

    // Get all team members (downline)
    const teamMembers = await getAllDownlineMembers(userId);
    const teamMemberIds = teamMembers.map(m => m._id);
    teamMemberIds.push(new mongoose.Types.ObjectId(userId)); // Include the user

    // Build query
    const query = { userId: { $in: teamMemberIds } };

    if (incomeType) query.incomeType = incomeType;
    if (status) query.status = status;
    if (legType) query.legType = legType;
    if (memberId) query.userId = memberId;
    if (startDate || endDate) {
      query.saleDate = {};
      if (startDate) query.saleDate.$gte = new Date(startDate);
      if (endDate) query.saleDate.$lte = new Date(endDate);
    }

    // Pagination
    const skip = (page - 1) * limit;
    const sortOptions = { [sortBy]: sortOrder === 'asc' ? 1 : -1 };

    // Execute query
    const records = await MatchingIncomeRecord.find(query)
      .populate('userId', 'username email personalInfo')
      .populate('plotId', 'plotNumber plotName')
      .populate('buyerId', 'username personalInfo')
      .populate('triggeredByPlotId', 'plotNumber plotName')
      .populate('pairedWith.plotId', 'plotNumber plotName')
      .populate('pairedWith.buyerId', 'username personalInfo')
      .sort(sortOptions)
      .skip(skip)
      .limit(parseInt(limit))
      .lean();

    const totalRecords = await MatchingIncomeRecord.countDocuments(query);

    // Calculate team summary
    const summaryPipeline = [
      { $match: query },
      {
        $group: {
          _id: null,
          totalTeamIncome: { $sum: '$incomeAmount' },
          totalTeamSales: { $sum: '$saleAmount' },
          totalTeamRecords: { $sum: 1 }
        }
      }
    ];

    const summaryResult = await MatchingIncomeRecord.aggregate(summaryPipeline);
    const summary = summaryResult[0] || { 
      totalTeamIncome: 0, 
      totalTeamSales: 0, 
      totalTeamRecords: 0 
    };

    // Income by type
    const incomeByType = await MatchingIncomeRecord.aggregate([
      { $match: query },
      {
        $group: {
          _id: '$incomeType',
          total: { $sum: '$incomeAmount' }
        }
      }
    ]);

    summary.incomeByType = {};
    incomeByType.forEach(item => {
      summary.incomeByType[item._id] = item.total;
    });

    // Income by status
    const incomeByStatus = await MatchingIncomeRecord.aggregate([
      { $match: query },
      {
        $group: {
          _id: '$status',
          total: { $sum: '$incomeAmount' }
        }
      }
    ]);

    summary.incomeByStatus = {};
    incomeByStatus.forEach(item => {
      summary.incomeByStatus[item._id] = item.total;
    });

    // Team stats
    summary.totalTeamMembers = teamMemberIds.length;
    summary.activeMembers = await User.countDocuments({
      _id: { $in: teamMemberIds },
      isActive: true
    });

    res.status(200).json({
      success: true,
      data: records,
      summary,
      pagination: {
        currentPage: parseInt(page),
        totalPages: Math.ceil(totalRecords / limit),
        totalRecords,
        limit: parseInt(limit)
      }
    });

  } catch (error) {
    console.error('Error in getTeamMatchingIncome:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'Failed to fetch team income'
    });
  }
};

/* ============================================================================ */
/* ðŸ”¶ ADMIN CONTROLLERS                                                        */
/* ============================================================================ */

/**
 * Get all income records with advanced filtering (Admin Only)
 * GET /api/matching-income/admin/all
 */
export const getAllIncomeRecords = async (req, res) => {
  try {
    const {
      incomeType,
      status,
      legType,
      eligibleOnly,
      startDate,
      endDate,
      page = 1,
      limit = 50,
      sortBy = 'saleDate',
      sortOrder = 'desc',
      search
    } = req.query;

    // Build query
    const query = {};

    if (incomeType) query.incomeType = incomeType;
    if (status) query.status = status;
    if (legType) query.legType = legType;
    if (startDate || endDate) {
      query.saleDate = {};
      if (startDate) query.saleDate.$gte = new Date(startDate);
      if (endDate) query.saleDate.$lte = new Date(endDate);
    }

    // Eligible only filter
    if (eligibleOnly === 'true') {
      query.status = 'eligible';
    }

    // Search filter
    if (search) {
      const users = await User.find({
        $or: [
          { username: { $regex: search, $options: 'i' } },
          { email: { $regex: search, $options: 'i' } }
        ]
      }).select('_id');

      const userIds = users.map(u => u._id);

      query.$or = [
        { plotNumber: { $regex: search, $options: 'i' } },
        { userId: { $in: userIds } }
      ];
    }

    // Pagination
    const skip = (page - 1) * limit;
    const sortOptions = { [sortBy]: sortOrder === 'asc' ? 1 : -1 };

    // Execute query
    const records = await MatchingIncomeRecord.find(query)
      .populate('userId', 'username email personalInfo')
      .populate('plotId', 'plotNumber plotName pricing')
      .populate('buyerId', 'username personalInfo')
      .populate('triggeredByPlotId', 'plotNumber plotName')
      .populate('pairedWith.plotId', 'plotNumber plotName')
      .populate('pairedWith.buyerId', 'username personalInfo')
      .populate('approvedBy', 'username')
      .populate('rejectedBy', 'username')
      .sort(sortOptions)
      .skip(skip)
      .limit(parseInt(limit))
      .lean();

    const totalRecords = await MatchingIncomeRecord.countDocuments(query);

    res.status(200).json({
      success: true,
      data: records,
      pagination: {
        currentPage: parseInt(page),
        totalPages: Math.ceil(totalRecords / limit),
        totalRecords,
        limit: parseInt(limit)
      }
    });

  } catch (error) {
    console.error('Error in getAllIncomeRecords:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'Failed to fetch income records'
    });
  }
};

/**
 * Get dashboard statistics (Admin Only)
 * GET /api/matching-income/admin/stats
 */
export const getDashboardStats = async (req, res) => {
  try {
    const now = new Date();
    const currentMonthStart = new Date(now.getFullYear(), now.getMonth(), 1);
    const lastMonthStart = new Date(now.getFullYear(), now.getMonth() - 1, 1);
    const lastMonthEnd = new Date(now.getFullYear(), now.getMonth(), 0);

    // Overall statistics
    const overallStats = await MatchingIncomeRecord.aggregate([
      {
        $group: {
          _id: null,
          totalRecords: { $sum: 1 },
          totalIncome: { $sum: '$incomeAmount' },
          totalSales: { $sum: '$saleAmount' }
        }
      }
    ]);

    // Current month stats
    const currentMonthStats = await MatchingIncomeRecord.aggregate([
      { $match: { createdAt: { $gte: currentMonthStart } } },
      {
        $group: {
          _id: '$status',
          count: { $sum: 1 },
          totalIncome: { $sum: '$incomeAmount' }
        }
      }
    ]);

    // Last month stats
    const lastMonthStats = await MatchingIncomeRecord.aggregate([
      { 
        $match: { 
          createdAt: { 
            $gte: lastMonthStart,
            $lte: lastMonthEnd
          } 
        } 
      },
      {
        $group: {
          _id: '$status',
          count: { $sum: 1 },
          totalIncome: { $sum: '$incomeAmount' }
        }
      }
    ]);

    // Eligible for approval
    const eligibleRecords = await MatchingIncomeRecord.find({
      status: 'eligible'
    });

    const eligibleForApproval = {
      count: eligibleRecords.length,
      amount: eligibleRecords.reduce((sum, r) => sum + r.incomeAmount, 0)
    };

    // Status breakdown
    const statusBreakdown = await MatchingIncomeRecord.aggregate([
      {
        $group: {
          _id: '$status',
          count: { $sum: 1 },
          totalIncome: { $sum: '$incomeAmount' }
        }
      }
    ]);

    // Income type breakdown
    const typeBreakdown = await MatchingIncomeRecord.aggregate([
      {
        $group: {
          _id: '$incomeType',
          count: { $sum: 1 },
          totalIncome: { $sum: '$incomeAmount' }
        }
      }
    ]);

    // Unique users count
    const uniqueUsers = await MatchingIncomeRecord.distinct('userId');

    // Format response
    const overall = overallStats[0] || { totalRecords: 0, totalIncome: 0, totalSales: 0 };
    overall.uniqueUsers = uniqueUsers.length;

    const currentMonth = {};
    currentMonthStats.forEach(stat => {
      currentMonth[stat._id] = {
        count: stat.count,
        totalIncome: stat.totalIncome
      };
    });

    const lastMonth = {};
    lastMonthStats.forEach(stat => {
      lastMonth[stat._id] = {
        count: stat.count,
        totalIncome: stat.totalIncome
      };
    });

    const statusBreakdownObj = {};
    statusBreakdown.forEach(stat => {
      statusBreakdownObj[stat._id] = {
        count: stat.count,
        totalIncome: stat.totalIncome
      };
    });

    const typeBreakdownObj = {};
    typeBreakdown.forEach(stat => {
      typeBreakdownObj[stat._id] = {
        count: stat.count,
        totalIncome: stat.totalIncome
      };
    });

    res.status(200).json({
      success: true,
      data: {
        overall,
        currentMonth,
        lastMonth,
        eligibleForApproval,
        statusBreakdown: statusBreakdownObj,
        typeBreakdown: typeBreakdownObj
      }
    });

  } catch (error) {
    console.error('Error in getDashboardStats:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'Failed to fetch dashboard stats'
    });
  }
};

/**
 * Approve a single income record (Admin Only) - IMMEDIATE APPROVAL
 * PATCH /api/matching-income/admin/approve/:recordId
 */
export const approveMatchingIncome = async (req, res) => {
  try {
    const { recordId } = req.params;
    const { adminId, notes } = req.body;

    if (!adminId) {
      return res.status(400).json({
        success: false,
        message: 'Admin ID is required'
      });
    }

    // Find the record
    const record = await MatchingIncomeRecord.findById(recordId);

    if (!record) {
      return res.status(404).json({
        success: false,
        message: 'Income record not found'
      });
    }

    // Check if already approved
    if (record.status === 'approved' || record.status === 'credited' || record.status === 'paid') {
      return res.status(400).json({
        success: false,
        message: 'Income record is already approved'
      });
    }

    // âœ… NO 3-MONTH LOCK CHECK - Approve immediately if status is eligible
    if (record.status !== 'eligible') {
      return res.status(400).json({
        success: false,
        message: 'Only eligible income can be approved'
      });
    }

    const now = new Date();

    // Update record
    record.status = 'approved';
    record.approvedBy = adminId;
    record.approvedAt = now;
    if (notes) record.adminNotes = notes;

    await record.save();

    // Populate before returning
    await record.populate([
      { path: 'userId', select: 'username email personalInfo' },
      { path: 'approvedBy', select: 'username' }
    ]);

    res.status(200).json({
      success: true,
      message: 'Income approved successfully',
      data: record
    });

  } catch (error) {
    console.error('Error in approveMatchingIncome:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'Failed to approve income'
    });
  }
};

/**
 * Bulk approve multiple income records (Admin Only) - IMMEDIATE APPROVAL
 * POST /api/matching-income/admin/bulk-approve
 */
export const bulkApproveIncome = async (req, res) => {
  try {
    const { adminId, recordIds, notes } = req.body;

    if (!adminId || !recordIds || !Array.isArray(recordIds) || recordIds.length === 0) {
      return res.status(400).json({
        success: false,
        message: 'Admin ID and record IDs are required'
      });
    }

    const now = new Date();
    const results = {
      approved: 0,
      skipped: 0,
      failed: 0,
      details: []
    };

    // Process each record
    for (const recordId of recordIds) {
      try {
        const record = await MatchingIncomeRecord.findById(recordId);

        if (!record) {
          results.failed++;
          results.details.push({
            recordId,
            status: 'failed',
            message: 'Record not found'
          });
          continue;
        }

        // Check if already approved
        if (['approved', 'credited', 'paid'].includes(record.status)) {
          results.skipped++;
          results.details.push({
            recordId,
            status: 'skipped',
            message: 'Already approved'
          });
          continue;
        }

        // âœ… NO 3-MONTH LOCK CHECK - Approve if eligible
        if (record.status !== 'eligible') {
          results.skipped++;
          results.details.push({
            recordId,
            status: 'skipped',
            message: 'Not eligible for approval'
          });
          continue;
        }

        // Approve the record
        record.status = 'approved';
        record.approvedBy = adminId;
        record.approvedAt = now;
        if (notes) record.adminNotes = notes;

        await record.save();

        results.approved++;
        results.details.push({
          recordId,
          status: 'approved',
          message: 'Successfully approved'
        });

      } catch (err) {
        results.failed++;
        results.details.push({
          recordId,
          status: 'failed',
          message: err.message
        });
      }
    }

    res.status(200).json({
      success: true,
      message: `Bulk approval completed: ${results.approved} approved, ${results.skipped} skipped, ${results.failed} failed`,
      data: results
    });

  } catch (error) {
    console.error('Error in bulkApproveIncome:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'Failed to bulk approve income'
    });
  }
};

/**
 * Reject an income record (Admin Only)
 * PATCH /api/matching-income/admin/reject/:recordId
 */
export const rejectMatchingIncome = async (req, res) => {
  try {
    const { recordId } = req.params;
    const { adminId, reason } = req.body;

    if (!adminId || !reason) {
      return res.status(400).json({
        success: false,
        message: 'Admin ID and rejection reason are required'
      });
    }

    const record = await MatchingIncomeRecord.findById(recordId);

    if (!record) {
      return res.status(404).json({
        success: false,
        message: 'Income record not found'
      });
    }

    // Update record
    record.status = 'rejected';
    record.rejectedBy = adminId;
    record.rejectedAt = new Date();
    record.rejectionReason = reason;

    await record.save();

    // Populate before returning
    await record.populate([
      { path: 'userId', select: 'username email personalInfo' },
      { path: 'rejectedBy', select: 'username' }
    ]);

    res.status(200).json({
      success: true,
      message: 'Income rejected successfully',
      data: record
    });

  } catch (error) {
    console.error('Error in rejectMatchingIncome:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'Failed to reject income'
    });
  }
};

/**
 * Update income status to credited/paid (Admin Only)
 * PATCH /api/matching-income/admin/status/:recordId
 */
export const updateIncomeStatus = async (req, res) => {
  try {
    const { recordId } = req.params;
    const { status, paymentDetails } = req.body;

    if (!status) {
      return res.status(400).json({
        success: false,
        message: 'Status is required'
      });
    }

    // Validate status
    const validStatuses = ['credited', 'paid'];
    if (!validStatuses.includes(status)) {
      return res.status(400).json({
        success: false,
        message: `Status must be one of: ${validStatuses.join(', ')}`
      });
    }

    const record = await MatchingIncomeRecord.findById(recordId);

    if (!record) {
      return res.status(404).json({
        success: false,
        message: 'Income record not found'
      });
    }

    // Check if record is approved
    if (record.status !== 'approved' && record.status !== 'credited') {
      return res.status(400).json({
        success: false,
        message: 'Only approved or credited income can be updated'
      });
    }

    // Update status
    record.status = status;

    // Update payment details if provided
    if (status === 'paid' && paymentDetails) {
      record.paymentDetails = {
        paidAmount: paymentDetails.paidAmount || record.incomeAmount,
        paidDate: paymentDetails.paidDate || new Date(),
        transactionId: paymentDetails.transactionId,
        paymentMode: paymentDetails.paymentMode
      };
    }

    await record.save();

    // Populate before returning
    await record.populate([
      { path: 'userId', select: 'username email personalInfo' }
    ]);

    res.status(200).json({
      success: true,
      message: `Income status updated to ${status} successfully`,
      data: record
    });

  } catch (error) {
    console.error('Error in updateIncomeStatus:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'Failed to update income status'
    });
  }
};

/* ============================================================================ */
/* ðŸ”§ HELPER FUNCTIONS                                                         */
/* ============================================================================ */

/**
 * Get all downline members recursively
 */
async function getAllDownlineMembers(userId, visited = new Set()) {
  const members = [];
  
  if (visited.has(userId.toString())) {
    return members;
  }
  
  visited.add(userId.toString());
  
  const children = await User.find({ sponsorId: userId })
    .select('_id username position')
    .lean();
  
  for (const child of children) {
    members.push(child);
    const descendants = await getAllDownlineMembers(child._id, visited);
    members.push(...descendants);
  }
  
  return members;
}

/**
 * Get user rewards and current level
 * GET /api/matching-income/rewards/:userId
 */
export const getUserRewards = async (req, res) => {
  try {
    const { userId } = req.params;

    // Get user's total income
    const incomeSummary = await MatchingIncomeRecord.aggregate([
      { $match: { userId: new mongoose.Types.ObjectId(userId), status: 'approved' } },
      {
        $group: {
          _id: null,
          totalIncome: { $sum: '$incomeAmount' },
          lastSaleDate: { $max: '$saleDate' }
        }
      }
    ]);

    const totalIncome = incomeSummary[0]?.totalIncome || 0;
    const lastSaleDate = incomeSummary[0]?.lastSaleDate || null;

    // Define reward levels
    const rewardLevels = [
      { role: 'Sales Executive', achieve: 700000, rewards: ['â‚¹15,000', '5G Mobile'], icon: 'ðŸ‘¨â€ðŸ’¼', imageUrl: 'https://akm-img-a-in.tosshub.com/indiatoday/images/story/202405/motorola-edge-50-pro-035026833-16x9.jpg?VersionId=i.ry9yloS2S8kSy39IME6FBQsqueNXyx' },
      { role: 'Sales Manager', achieve: 2000000, rewards: ['â‚¹50,000', 'Laptop i7', 'Foreign Trip 3N-4D'], icon: 'ðŸ‘”', imageUrl: 'https://static.digit.in/default/63043a830597c650a77e5b892de23c519eb5100e.jpeg' },
      { role: 'Territory Manager', achieve: 5000000, rewards: ['â‚¹1,25,000', 'Bike'], icon: 'ðŸï¸', imageUrl: 'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRYICm1kk49sIHI_tegQm0QeB6fvL7VJfnLAg&s' },
      { role: 'Divisional Manager', achieve: 10000000, rewards: ['â‚¹2,50,000', 'Bullet'], icon: 'ðŸï¸', imageUrl: 'https://imgd.aeplcdn.com/1280x720/n/cw/ec/156643/royalenfield-bullet-right-front-three-quarter3.jpeg?isig=0&wm=3' },
      { role: 'Regional Manager', achieve: 30000000, rewards: ['â‚¹7,50,000', 'Swift Car'], icon: 'ðŸš—', imageUrl: 'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTVvJgdjxkP0WFDAGBP3ko2P2pPQL3K9fGeVg&s' },
      { role: 'Zonal Manager', achieve: 80000000, rewards: ['â‚¹20,00,000', 'Tata Safari'], icon: 'ðŸš™', imageUrl: 'https://cdni.autocarindia.com/ExtraImages/20210204105942_2021_Tata_Safari_white_front.jpg' },
      { role: 'Vice President', achieve: 100000000, rewards: ['â‚¹2,50,00,000', 'Farm House'], icon: 'ðŸ¡', imageUrl: 'https://t4.ftcdn.net/jpg/01/64/59/65/360_F_164596597_K4cn0KhFQ1R6USGg10xAN9IsHJNLQRkb.jpg' },
      { role: 'General Manager', achieve: 50000000, rewards: ['â‚¹1,25,00,000', 'Luxury Bungalow'], icon: 'ðŸ˜ï¸', imageUrl: 'https://media.inmobalia.com/imgV1/B95mbh8olwFQm~uCUaVOI2kQT0hb0a8sZ9turUNfnwtvuccYCzs0YVPfPbfkc2VnnN1JFDpiXNU9xzJ~Ag4BlYYPYZFIAjR7mCUc5JBLZPdgYJCxR1v5rEuUzU_c2l5t5RfA9A4ibbDcCe10wLVTA1gzagr2V3lBJiT7AZrQwB0hDkvTgaLD_paCEArhEnq8vZRo~5EsD4KnhBpeRR6wl14AfUVUY9d3J9Ih5kJFwzq7eRBg1Xs1c8fBJ3sutGCYoLfMyae~hKabvRxbS02z508fgWrSsd~RZvDcxlVTBWcMS~92Gj21s9Oizf2_G83WhPaqKRghQiWKpV3e6JPRkBrUnDS9vb91IqeGGkR5fc_~y5iYifxFGDsBRMuXKTp7HcnjfKB19Nuw50aPfi7uBdn_fyl5sd0qS17J1WQgSCpiyK_6K_Ozqg--.jpg' },
      { role: 'Assistant General Manager', achieve: 25000000, rewards: ['â‚¹62,50,000', 'Duplex 1200 sqft'], icon: 'ðŸ ', imageUrl: 'https://www.luxuryresidences.in/generic-assest/images/gurgaon/central-park-sky-villas.jpg' },
      { role: 'President', achieve: 200000000, rewards: ['â‚¹5,00,00,000', 'Cruise Yacht'], icon: 'ðŸ›³ï¸', imageUrl: 'https://images.unsplash.com/photo-1569263979104-865ab7cd8d13?fm=jpg&q=60&w=3000&ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxzZWFyY2h8M3x8eWFjaHR8ZW58MHx8MHx8fDA%3D' },
      { role: 'Sales Director', achieve: 500000000, rewards: ['â‚¹12,50,00,000', 'Helicopter'], icon: 'ðŸš', imageUrl: 'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTnU0o6_1duTQyadQD_1JWZXI7vRqtjV_ATqQ&s' }
    ];

    // Determine current level
    let currentLevel = null;
    let currentLevelIndex = -1;

    for (let i = rewardLevels.length - 1; i >= 0; i--) {
      if (totalIncome >= rewardLevels[i].achieve) {
        currentLevel = rewardLevels[i];
        currentLevelIndex = i;
        break;
      }
    }

    // Check lock status for each level
    const rewardsWithStatus = rewardLevels.map((level, index) => {
      const isAchieved = totalIncome >= level.achieve;
      let isLocked = true;
      let lockReason = '';

      if (isAchieved) {
        if (lastSaleDate) {
          const threeMonthsAfter = new Date(lastSaleDate);
          threeMonthsAfter.setMonth(threeMonthsAfter.getMonth() + 3);
          const now = new Date();

          if (now >= threeMonthsAfter) {
            isLocked = false;
          } else {
            lockReason = `Available after ${threeMonthsAfter.toLocaleDateString()}`;
          }
        } else {
          isLocked = false; // No sales yet, but achieved? This shouldn't happen
        }
      } else {
        lockReason = `Achieve â‚¹${level.achieve.toLocaleString('en-IN')} to unlock`;
      }

      return {
        ...level,
        isAchieved,
        isLocked,
        lockReason,
        isCurrentLevel: index === currentLevelIndex
      };
    });

    res.status(200).json({
      success: true,
      data: {
        totalIncome,
        lastSaleDate,
        currentLevel,
        rewards: rewardsWithStatus
      }
    });

  } catch (error) {
    console.error('Error in getUserRewards:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'Failed to fetch rewards'
    });
  }
};

export default {
  getUserMatchingIncome,
  getPlotIncomeDetails,
  getIncomeSummary,
  getTeamMatchingIncome,
  getAllIncomeRecords,
  getDashboardStats,
  approveMatchingIncome,
  bulkApproveIncome,
  rejectMatchingIncome,
  updateIncomeStatus,
  getUserRewards
};