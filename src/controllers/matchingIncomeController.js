// controllers/matchingIncomeController.js - Complete Implementation
import { MatchingIncomeRecord } from '../models/matchingIncomeSchema.js';
import { User } from '../models/userSchema.js';
import { Plot } from '../models/plotBooking.js';
import mongoose from 'mongoose';

/* ============================================================================ */
/* ðŸ”· USER CONTROLLERS                                                         */
/* ============================================================================ */

/**
 * Get individual matching income records for a user
 * GET /api/matching-income/user/:userId
 */
export const getUserMatchingIncome = async (req, res) => {
  try {
    const { userId } = req.params;
    const {
      incomeType,
      status,
      legType,
      startDate,
      endDate,
      page = 1,
      limit = 20,
      sortBy = 'saleDate',
      sortOrder = 'desc'
    } = req.query;

    // Build query
    const query = { userId };

    if (incomeType) query.incomeType = incomeType;
    if (status) query.status = status;
    if (legType) query.legType = legType;
    if (startDate || endDate) {
      query.saleDate = {};
      if (startDate) query.saleDate.$gte = new Date(startDate);
      if (endDate) query.saleDate.$lte = new Date(endDate);
    }

    // Pagination
    const skip = (page - 1) * limit;
    const sortOptions = { [sortBy]: sortOrder === 'asc' ? 1 : -1 };

    // Execute query with population
    const records = await MatchingIncomeRecord.find(query)
      .populate('userId', 'username email personalInfo')
      .populate('plotId', 'plotNumber plotName')
      .populate('buyerId', 'username personalInfo')
      .populate('triggeredByPlotId', 'plotNumber plotName')
      .populate('pairedWith.plotId', 'plotNumber plotName')
      .populate('pairedWith.buyerId', 'username personalInfo')
      .populate('approvedBy', 'username')
      .populate('rejectedBy', 'username')
      .sort(sortOptions)
      .skip(skip)
      .limit(parseInt(limit))
      .lean();

    // Get total count for pagination
    const totalRecords = await MatchingIncomeRecord.countDocuments(query);

    // Calculate summary statistics
    const summaryPipeline = [
      { $match: query },
      {
        $group: {
          _id: null,
          totalIncome: { $sum: '$incomeAmount' },
          totalRecords: { $sum: 1 },
          totalSales: { $sum: '$saleAmount' }
        }
      }
    ];

    const summaryResult = await MatchingIncomeRecord.aggregate(summaryPipeline);
    const summary = summaryResult[0] || { totalIncome: 0, totalRecords: 0, totalSales: 0 };

    // Income by type
    const incomeByType = await MatchingIncomeRecord.aggregate([
      { $match: query },
      {
        $group: {
          _id: '$incomeType',
          total: { $sum: '$incomeAmount' },
          count: { $sum: 1 }
        }
      }
    ]);

    summary.incomeByType = {};
    incomeByType.forEach(item => {
      summary.incomeByType[item._id] = item.total;
    });

    // Income by status
    const incomeByStatus = await MatchingIncomeRecord.aggregate([
      { $match: query },
      {
        $group: {
          _id: '$status',
          total: { $sum: '$incomeAmount' },
          count: { $sum: 1 }
        }
      }
    ]);

    summary.incomeByStatus = {};
    incomeByStatus.forEach(item => {
      summary.incomeByStatus[item._id] = item.total;
    });

    // Eligible for approval
    const eligibleRecords = await MatchingIncomeRecord.find({
      ...query,
      status: { $in: ['pending', 'eligible'] },
      eligibleForApprovalDate: { $lte: new Date() }
    });

    summary.eligibleForApproval = {
      count: eligibleRecords.length,
      amount: eligibleRecords.reduce((sum, r) => sum + r.incomeAmount, 0)
    };

    res.status(200).json({
      success: true,
      data: records,
      summary,
      pagination: {
        currentPage: parseInt(page),
        totalPages: Math.ceil(totalRecords / limit),
        totalRecords,
        limit: parseInt(limit)
      }
    });

  } catch (error) {
    console.error('Error in getUserMatchingIncome:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'Failed to fetch income records'
    });
  }
};

/**
 * Get income details for a specific plot
 * GET /api/matching-income/plot/:plotId
 */
export const getPlotIncomeDetails = async (req, res) => {
  try {
    const { plotId } = req.params;

    // Get all income records generated by this plot
    const records = await MatchingIncomeRecord.find({
      $or: [
        { plotId },
        { triggeredByPlotId: plotId },
        { 'pairedWith.plotId': plotId }
      ]
    })
      .populate('userId', 'username email personalInfo')
      .populate('plotId', 'plotNumber plotName')
      .populate('buyerId', 'username personalInfo')
      .populate('triggeredByPlotId', 'plotNumber plotName')
      .sort({ saleDate: -1 })
      .lean();

    // Get plot details
    const plot = await Plot.findById(plotId)
      .populate('bookingDetails.buyerId', 'username personalInfo')
      .lean();

    if (!plot) {
      return res.status(404).json({
        success: false,
        message: 'Plot not found'
      });
    }

    // Calculate totals
    const totalIncome = records.reduce((sum, r) => sum + r.incomeAmount, 0);
    const personalSaleIncome = records
      .filter(r => r.incomeType === 'personal_sale')
      .reduce((sum, r) => sum + r.incomeAmount, 0);
    const matchingBonusIncome = records
      .filter(r => r.incomeType === 'matching_bonus')
      .reduce((sum, r) => sum + r.incomeAmount, 0);

    res.status(200).json({
      success: true,
      data: {
        plot,
        records,
        summary: {
          totalIncome,
          personalSaleIncome,
          matchingBonusIncome,
          totalRecords: records.length
        }
      }
    });

  } catch (error) {
    console.error('Error in getPlotIncomeDetails:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'Failed to fetch plot income details'
    });
  }
};

/**
 * Get income summary grouped by time period
 * GET /api/matching-income/summary/:userId
 */
export const getIncomeSummary = async (req, res) => {
  try {
    const { userId } = req.params;
    const { startDate, endDate, groupBy = 'month' } = req.query;

    const matchStage = { userId: new mongoose.Types.ObjectId(userId) };

    if (startDate || endDate) {
      matchStage.saleDate = {};
      if (startDate) matchStage.saleDate.$gte = new Date(startDate);
      if (endDate) matchStage.saleDate.$lte = new Date(endDate);
    }

    // Determine grouping format
    let dateFormat;
    switch (groupBy) {
      case 'day':
        dateFormat = { $dateToString: { format: '%Y-%m-%d', date: '$saleDate' } };
        break;
      case 'year':
        dateFormat = { $dateToString: { format: '%Y', date: '$saleDate' } };
        break;
      default: // month
        dateFormat = { $dateToString: { format: '%Y-%m', date: '$saleDate' } };
    }

    const pipeline = [
      { $match: matchStage },
      {
        $group: {
          _id: {
            period: dateFormat,
            incomeType: '$incomeType',
            status: '$status'
          },
          totalIncome: { $sum: '$incomeAmount' },
          totalSales: { $sum: '$saleAmount' },
          count: { $sum: 1 }
        }
      },
      { $sort: { '_id.period': 1 } }
    ];

    const results = await MatchingIncomeRecord.aggregate(pipeline);

    // Transform results into a more readable format
    const summary = {};
    results.forEach(item => {
      const period = item._id.period;
      if (!summary[period]) {
        summary[period] = {
          period,
          totalIncome: 0,
          totalSales: 0,
          totalRecords: 0,
          byType: {},
          byStatus: {}
        };
      }

      summary[period].totalIncome += item.totalIncome;
      summary[period].totalSales += item.totalSales;
      summary[period].totalRecords += item.count;

      if (!summary[period].byType[item._id.incomeType]) {
        summary[period].byType[item._id.incomeType] = 0;
      }
      summary[period].byType[item._id.incomeType] += item.totalIncome;

      if (!summary[period].byStatus[item._id.status]) {
        summary[period].byStatus[item._id.status] = 0;
      }
      summary[period].byStatus[item._id.status] += item.totalIncome;
    });

    res.status(200).json({
      success: true,
      data: Object.values(summary),
      groupBy
    });

  } catch (error) {
    console.error('Error in getIncomeSummary:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'Failed to fetch income summary'
    });
  }
};

/**
 * Get team income records (all downline members)
 * GET /api/matching-income/team/:userId
 */
export const getTeamMatchingIncome = async (req, res) => {
  try {
    const { userId } = req.params;
    const {
      incomeType,
      status,
      legType,
      startDate,
      endDate,
      memberId,
      page = 1,
      limit = 50,
      sortBy = 'saleDate',
      sortOrder = 'desc'
    } = req.query;

    // Get all team members (downline)
    const teamMembers = await getAllDownlineMembers(userId);
    const teamMemberIds = teamMembers.map(m => m._id);
    teamMemberIds.push(new mongoose.Types.ObjectId(userId)); // Include the user

    // Build query
    const query = { userId: { $in: teamMemberIds } };

    if (incomeType) query.incomeType = incomeType;
    if (status) query.status = status;
    if (legType) query.legType = legType;
    if (memberId) query.userId = memberId;
    if (startDate || endDate) {
      query.saleDate = {};
      if (startDate) query.saleDate.$gte = new Date(startDate);
      if (endDate) query.saleDate.$lte = new Date(endDate);
    }

    // Pagination
    const skip = (page - 1) * limit;
    const sortOptions = { [sortBy]: sortOrder === 'asc' ? 1 : -1 };

    // Execute query
    const records = await MatchingIncomeRecord.find(query)
      .populate('userId', 'username email personalInfo')
      .populate('plotId', 'plotNumber plotName')
      .populate('buyerId', 'username personalInfo')
      .populate('triggeredByPlotId', 'plotNumber plotName')
      .populate('pairedWith.plotId', 'plotNumber plotName')
      .populate('pairedWith.buyerId', 'username personalInfo')
      .sort(sortOptions)
      .skip(skip)
      .limit(parseInt(limit))
      .lean();

    const totalRecords = await MatchingIncomeRecord.countDocuments(query);

    // Calculate team summary
    const summaryPipeline = [
      { $match: query },
      {
        $group: {
          _id: null,
          totalTeamIncome: { $sum: '$incomeAmount' },
          totalTeamSales: { $sum: '$saleAmount' },
          totalTeamRecords: { $sum: 1 }
        }
      }
    ];

    const summaryResult = await MatchingIncomeRecord.aggregate(summaryPipeline);
    const summary = summaryResult[0] || { 
      totalTeamIncome: 0, 
      totalTeamSales: 0, 
      totalTeamRecords: 0 
    };

    // Income by type
    const incomeByType = await MatchingIncomeRecord.aggregate([
      { $match: query },
      {
        $group: {
          _id: '$incomeType',
          total: { $sum: '$incomeAmount' }
        }
      }
    ]);

    summary.incomeByType = {};
    incomeByType.forEach(item => {
      summary.incomeByType[item._id] = item.total;
    });

    // Income by status
    const incomeByStatus = await MatchingIncomeRecord.aggregate([
      { $match: query },
      {
        $group: {
          _id: '$status',
          total: { $sum: '$incomeAmount' }
        }
      }
    ]);

    summary.incomeByStatus = {};
    incomeByStatus.forEach(item => {
      summary.incomeByStatus[item._id] = item.total;
    });

    // Team stats
    summary.totalTeamMembers = teamMemberIds.length;
    summary.activeMembers = await User.countDocuments({
      _id: { $in: teamMemberIds },
      isActive: true
    });

    res.status(200).json({
      success: true,
      data: records,
      summary,
      pagination: {
        currentPage: parseInt(page),
        totalPages: Math.ceil(totalRecords / limit),
        totalRecords,
        limit: parseInt(limit)
      }
    });

  } catch (error) {
    console.error('Error in getTeamMatchingIncome:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'Failed to fetch team income'
    });
  }
};

/* ============================================================================ */
/* ðŸ”¶ ADMIN CONTROLLERS                                                        */
/* ============================================================================ */

/**
 * Get all income records with advanced filtering (Admin Only)
 * GET /api/matching-income/admin/all
 */
export const getAllIncomeRecords = async (req, res) => {
  try {
    const {
      incomeType,
      status,
      legType,
      eligibleOnly,
      startDate,
      endDate,
      page = 1,
      limit = 50,
      sortBy = 'saleDate',
      sortOrder = 'desc',
      search
    } = req.query;

    // Build query
    const query = {};

    if (incomeType) query.incomeType = incomeType;
    if (status) query.status = status;
    if (legType) query.legType = legType;
    if (startDate || endDate) {
      query.saleDate = {};
      if (startDate) query.saleDate.$gte = new Date(startDate);
      if (endDate) query.saleDate.$lte = new Date(endDate);
    }

    // Eligible only filter
    if (eligibleOnly === 'true') {
      query.status = { $in: ['pending', 'eligible'] };
      query.eligibleForApprovalDate = { $lte: new Date() };
    }

    // Search filter
    if (search) {
      const users = await User.find({
        $or: [
          { username: { $regex: search, $options: 'i' } },
          { email: { $regex: search, $options: 'i' } }
        ]
      }).select('_id');

      const userIds = users.map(u => u._id);

      query.$or = [
        { plotNumber: { $regex: search, $options: 'i' } },
        { userId: { $in: userIds } }
      ];
    }

    // Pagination
    const skip = (page - 1) * limit;
    const sortOptions = { [sortBy]: sortOrder === 'asc' ? 1 : -1 };

    // Execute query
    const records = await MatchingIncomeRecord.find(query)
      .populate('userId', 'username email personalInfo')
      .populate('plotId', 'plotNumber plotName pricing')
      .populate('buyerId', 'username personalInfo')
      .populate('triggeredByPlotId', 'plotNumber plotName')
      .populate('pairedWith.plotId', 'plotNumber plotName')
      .populate('pairedWith.buyerId', 'username personalInfo')
      .populate('approvedBy', 'username')
      .populate('rejectedBy', 'username')
      .sort(sortOptions)
      .skip(skip)
      .limit(parseInt(limit))
      .lean();

    const totalRecords = await MatchingIncomeRecord.countDocuments(query);

    res.status(200).json({
      success: true,
      data: records,
      pagination: {
        currentPage: parseInt(page),
        totalPages: Math.ceil(totalRecords / limit),
        totalRecords,
        limit: parseInt(limit)
      }
    });

  } catch (error) {
    console.error('Error in getAllIncomeRecords:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'Failed to fetch income records'
    });
  }
};

/**
 * Get dashboard statistics (Admin Only)
 * GET /api/matching-income/admin/stats
 */
export const getDashboardStats = async (req, res) => {
  try {
    const now = new Date();
    const currentMonthStart = new Date(now.getFullYear(), now.getMonth(), 1);
    const lastMonthStart = new Date(now.getFullYear(), now.getMonth() - 1, 1);
    const lastMonthEnd = new Date(now.getFullYear(), now.getMonth(), 0);

    // Overall statistics
    const overallStats = await MatchingIncomeRecord.aggregate([
      {
        $group: {
          _id: null,
          totalRecords: { $sum: 1 },
          totalIncome: { $sum: '$incomeAmount' },
          totalSales: { $sum: '$saleAmount' }
        }
      }
    ]);

    // Current month stats
    const currentMonthStats = await MatchingIncomeRecord.aggregate([
      { $match: { createdAt: { $gte: currentMonthStart } } },
      {
        $group: {
          _id: '$status',
          count: { $sum: 1 },
          totalIncome: { $sum: '$incomeAmount' }
        }
      }
    ]);

    // Last month stats
    const lastMonthStats = await MatchingIncomeRecord.aggregate([
      { 
        $match: { 
          createdAt: { 
            $gte: lastMonthStart,
            $lte: lastMonthEnd
          } 
        } 
      },
      {
        $group: {
          _id: '$status',
          count: { $sum: 1 },
          totalIncome: { $sum: '$incomeAmount' }
        }
      }
    ]);

    // Eligible for approval
    const eligibleRecords = await MatchingIncomeRecord.find({
      status: { $in: ['pending', 'eligible'] },
      eligibleForApprovalDate: { $lte: now }
    });

    const eligibleForApproval = {
      count: eligibleRecords.length,
      amount: eligibleRecords.reduce((sum, r) => sum + r.incomeAmount, 0)
    };

    // Status breakdown
    const statusBreakdown = await MatchingIncomeRecord.aggregate([
      {
        $group: {
          _id: '$status',
          count: { $sum: 1 },
          totalIncome: { $sum: '$incomeAmount' }
        }
      }
    ]);

    // Income type breakdown
    const typeBreakdown = await MatchingIncomeRecord.aggregate([
      {
        $group: {
          _id: '$incomeType',
          count: { $sum: 1 },
          totalIncome: { $sum: '$incomeAmount' }
        }
      }
    ]);

    // Unique users count
    const uniqueUsers = await MatchingIncomeRecord.distinct('userId');

    // Format response
    const overall = overallStats[0] || { totalRecords: 0, totalIncome: 0, totalSales: 0 };
    overall.uniqueUsers = uniqueUsers.length;

    const currentMonth = {};
    currentMonthStats.forEach(stat => {
      currentMonth[stat._id] = {
        count: stat.count,
        totalIncome: stat.totalIncome
      };
    });

    const lastMonth = {};
    lastMonthStats.forEach(stat => {
      lastMonth[stat._id] = {
        count: stat.count,
        totalIncome: stat.totalIncome
      };
    });

    const statusBreakdownObj = {};
    statusBreakdown.forEach(stat => {
      statusBreakdownObj[stat._id] = {
        count: stat.count,
        totalIncome: stat.totalIncome
      };
    });

    const typeBreakdownObj = {};
    typeBreakdown.forEach(stat => {
      typeBreakdownObj[stat._id] = {
        count: stat.count,
        totalIncome: stat.totalIncome
      };
    });

    res.status(200).json({
      success: true,
      data: {
        overall,
        currentMonth,
        lastMonth,
        eligibleForApproval,
        statusBreakdown: statusBreakdownObj,
        typeBreakdown: typeBreakdownObj
      }
    });

  } catch (error) {
    console.error('Error in getDashboardStats:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'Failed to fetch dashboard stats'
    });
  }
};

/**
 * Approve a single income record (Admin Only)
 * PATCH /api/matching-income/admin/approve/:recordId
 */
export const approveMatchingIncome = async (req, res) => {
  try {
    const { recordId } = req.params;
    const { adminId, notes } = req.body;

    if (!adminId) {
      return res.status(400).json({
        success: false,
        message: 'Admin ID is required'
      });
    }

    // Find the record
    const record = await MatchingIncomeRecord.findById(recordId);

    if (!record) {
      return res.status(404).json({
        success: false,
        message: 'Income record not found'
      });
    }

    // Check if already approved
    if (record.status === 'approved' || record.status === 'credited' || record.status === 'paid') {
      return res.status(400).json({
        success: false,
        message: 'Income record is already approved'
      });
    }

    // Check 3-month lock
    const now = new Date();
    const eligibleDate = new Date(record.eligibleForApprovalDate);

    if (now < eligibleDate) {
      const daysRemaining = Math.ceil((eligibleDate - now) / (1000 * 60 * 60 * 24));
      return res.status(400).json({
        success: false,
        message: `Cannot approve yet. Income becomes eligible in ${daysRemaining} days (on ${eligibleDate.toLocaleDateString()})`
      });
    }

    // Update record
    record.status = 'approved';
    record.approvedBy = adminId;
    record.approvedAt = now;
    if (notes) record.adminNotes = notes;

    await record.save();

    // Populate before returning
    await record.populate([
      { path: 'userId', select: 'username email personalInfo' },
      { path: 'approvedBy', select: 'username' }
    ]);

    res.status(200).json({
      success: true,
      message: 'Income approved successfully',
      data: record
    });

  } catch (error) {
    console.error('Error in approveMatchingIncome:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'Failed to approve income'
    });
  }
};

/**
 * Bulk approve multiple income records (Admin Only)
 * POST /api/matching-income/admin/bulk-approve
 */
export const bulkApproveIncome = async (req, res) => {
  try {
    const { adminId, recordIds, notes } = req.body;

    if (!adminId || !recordIds || !Array.isArray(recordIds) || recordIds.length === 0) {
      return res.status(400).json({
        success: false,
        message: 'Admin ID and record IDs are required'
      });
    }

    const now = new Date();
    const results = {
      approved: 0,
      skipped: 0,
      failed: 0,
      details: []
    };

    // Process each record
    for (const recordId of recordIds) {
      try {
        const record = await MatchingIncomeRecord.findById(recordId);

        if (!record) {
          results.failed++;
          results.details.push({
            recordId,
            status: 'failed',
            message: 'Record not found'
          });
          continue;
        }

        // Check if already approved
        if (['approved', 'credited', 'paid'].includes(record.status)) {
          results.skipped++;
          results.details.push({
            recordId,
            status: 'skipped',
            message: 'Already approved'
          });
          continue;
        }

        // Check 3-month lock
        const eligibleDate = new Date(record.eligibleForApprovalDate);
        if (now < eligibleDate) {
          results.skipped++;
          results.details.push({
            recordId,
            status: 'skipped',
            message: 'Not eligible yet (3-month lock)'
          });
          continue;
        }

        // Approve the record
        record.status = 'approved';
        record.approvedBy = adminId;
        record.approvedAt = now;
        if (notes) record.adminNotes = notes;

        await record.save();

        results.approved++;
        results.details.push({
          recordId,
          status: 'approved',
          message: 'Successfully approved'
        });

      } catch (err) {
        results.failed++;
        results.details.push({
          recordId,
          status: 'failed',
          message: err.message
        });
      }
    }

    res.status(200).json({
      success: true,
      message: `Bulk approval completed: ${results.approved} approved, ${results.skipped} skipped, ${results.failed} failed`,
      data: results
    });

  } catch (error) {
    console.error('Error in bulkApproveIncome:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'Failed to bulk approve income'
    });
  }
};

/**
 * Reject an income record (Admin Only)
 * PATCH /api/matching-income/admin/reject/:recordId
 */
export const rejectMatchingIncome = async (req, res) => {
  try {
    const { recordId } = req.params;
    const { adminId, reason } = req.body;

    if (!adminId || !reason) {
      return res.status(400).json({
        success: false,
        message: 'Admin ID and rejection reason are required'
      });
    }

    const record = await MatchingIncomeRecord.findById(recordId);

    if (!record) {
      return res.status(404).json({
        success: false,
        message: 'Income record not found'
      });
    }

    // Update record
    record.status = 'rejected';
    record.rejectedBy = adminId;
    record.rejectedAt = new Date();
    record.rejectionReason = reason;

    await record.save();

    // Populate before returning
    await record.populate([
      { path: 'userId', select: 'username email personalInfo' },
      { path: 'rejectedBy', select: 'username' }
    ]);

    res.status(200).json({
      success: true,
      message: 'Income rejected successfully',
      data: record
    });

  } catch (error) {
    console.error('Error in rejectMatchingIncome:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'Failed to reject income'
    });
  }
};

/**
 * Update income status to credited/paid (Admin Only)
 * PATCH /api/matching-income/admin/status/:recordId
 */
export const updateIncomeStatus = async (req, res) => {
  try {
    const { recordId } = req.params;
    const { status, paymentDetails } = req.body;

    if (!status) {
      return res.status(400).json({
        success: false,
        message: 'Status is required'
      });
    }

    // Validate status
    const validStatuses = ['credited', 'paid'];
    if (!validStatuses.includes(status)) {
      return res.status(400).json({
        success: false,
        message: `Status must be one of: ${validStatuses.join(', ')}`
      });
    }

    const record = await MatchingIncomeRecord.findById(recordId);

    if (!record) {
      return res.status(404).json({
        success: false,
        message: 'Income record not found'
      });
    }

    // Check if record is approved
    if (record.status !== 'approved' && record.status !== 'credited') {
      return res.status(400).json({
        success: false,
        message: 'Only approved or credited income can be updated'
      });
    }

    // Update status
    record.status = status;

    // Update payment details if provided
    if (status === 'paid' && paymentDetails) {
      record.paymentDetails = {
        paidAmount: paymentDetails.paidAmount || record.incomeAmount,
        paidDate: paymentDetails.paidDate || new Date(),
        transactionId: paymentDetails.transactionId,
        paymentMode: paymentDetails.paymentMode
      };
    }

    await record.save();

    // Populate before returning
    await record.populate([
      { path: 'userId', select: 'username email personalInfo' }
    ]);

    res.status(200).json({
      success: true,
      message: `Income status updated to ${status} successfully`,
      data: record
    });

  } catch (error) {
    console.error('Error in updateIncomeStatus:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'Failed to update income status'
    });
  }
};

/* ============================================================================ */
/* ðŸ”§ HELPER FUNCTIONS                                                         */
/* ============================================================================ */

/**
 * Get all downline members recursively
 */
async function getAllDownlineMembers(userId, visited = new Set()) {
  const members = [];
  
  if (visited.has(userId.toString())) {
    return members;
  }
  
  visited.add(userId.toString());
  
  const children = await User.find({ sponsorId: userId })
    .select('_id username position')
    .lean();
  
  for (const child of children) {
    members.push(child);
    const descendants = await getAllDownlineMembers(child._id, visited);
    members.push(...descendants);
  }
  
  return members;
}

export default {
  getUserMatchingIncome,
  getPlotIncomeDetails,
  getIncomeSummary,
  getTeamMatchingIncome,
  getAllIncomeRecords,
  getDashboardStats,
  approveMatchingIncome,
  bulkApproveIncome,
  rejectMatchingIncome,
  updateIncomeStatus
};